---
pageClass: custom-page-class
---

# 1057 Stack (30)★★★☆

这道题有些变态。总共5个测试点，3个都是超大数情况，一提交，三个都是绿的。
github地址：[https://github.com/iofu728/PAT-A-by-iofu728](https://github.com/iofu728/PAT-A-by-iofu728)
难度：★★★☆
关键词：二分查找,分组,模拟栈
### 题目

> 1057.Stack (30)
> Stack is one of the most fundamental data structures, which is based on the principle of Last In First Out (LIFO). The basic operations include Push (inserting an element onto the top position) and Pop (deleting the top element). Now you are supposed to implement a stack with an extra operation: PeekMedian — return the median value of all the elements in the stack. With N elements, the median value is defined to be the (N/2)-th smallest element if N is even, or ((N+1)/2)-th if N is odd.
>
> Input Specification:
>
> Each input file contains one test case. For each case, the first line contains a positive integer N (<= 105). Then N lines follow, each contains a command in one of the following 3 formats:
>
> Push key
> Pop
> PeekMedian
> where key is a positive integer no more than 105.
>
> Output Specification:
>
> For each Push command, insert key into the stack and output nothing. For each Pop or PeekMedian command, print in a line the corresponding returned value. If the command is invalid, print “Invalid” instead.
>
> Sample Input:
> 17
> Pop
> PeekMedian
> Push 3
> PeekMedian
> Push 2
> PeekMedian
> Push 1
> PeekMedian
> Pop
> Pop
> Push 5
> Push 4
> PeekMedian
> Pop
> Pop
> Pop
> Pop
>
> Sample Output:
> Invalid
> Invalid
> 3
> 2
> 2
> 1
> 2
> 4
> 4
> 5
> 3
> Invalid
### 大意
完成栈stack的模拟，除了最基本的push，pop功能之外，还加了一个输出中间数（从小到大排序最中间的数字）。若stack为空，push和peekMedian无效。
### 思路
1. 单纯的栈模拟比较简单，使用stack容器，分别在相应的操作字符下进行相应的操作。
2. 关键是peekMedian。一开始想的比较简单，同步设了一个vector模块，进行排序操作，pop的时候使用find()+erase()两个函数进行操作。
当然不出意外的超时了。
因为是从小到大大排序，马上想到用set容器，set容器排序。但是有两个问题，
  - set没法随机查找，导致我们想读取第k个元素，只能使用循环移动iterator，复杂度不低。
  - 比较致命的是，set不含重复元素。于是这条路没法用。
3. 重新想下如果我们插入num到数组时候就是按顺序插入的话，那不用排序了，问题就转变为二分插入，也就是二分查找。这条路可以走的通。
4. 因为我们所有key都是正整数，所以在模拟问题的时候，可以用个hash表来记录已经出现的数字的个数，hash从小到大排好，从下往上遍历。
如果单纯这样，复杂度也很大，但hash表设置的时候可以考虑二维哈希，或者叫他分组。这样就可以得到原来的根号倍复杂度。

### code
```cpp
#include <algorithm>
#include <iostream>
#include <stack>
#include <vector>
using namespace std;
const int BMAX = 317;
const int BNUM = 316;
const int MAXN = 100010;
int b[BMAX] = {0}, a[MAXN] = {0};
stack<int> s;
void findmid() {
  int mid = (s.size() + 1) / 2, sum = 0, i, j;
  for (i = 0; i <= BMAX; ++i) {
    if (sum + b[i] >= mid) {
      break;
    }
    sum += b[i];
  }
  for (j = i * BNUM; j < MAXN; ++j) {
    sum += a[j];
    if (sum >= mid) break;
  }
  printf("%d\n", j);
  return;
}
int main() {
  int n;
  scanf("%d", &n);
  for (int i = 0; i < n; ++i) {
    char formats[11];
    int num;
    scanf("%s", formats);
    if (formats[1] == 'u') {
      scanf("%d", &num);
      s.push(num);
      ++b[num / BNUM];
      ++a[num];
    } else {
      if (s.empty()) {
        printf("Invalid\n");
      } else if (formats[1] == 'o') {
        int temp = s.top();
        s.pop();
        printf("%d\n", temp);
        --b[temp / BNUM];
        --a[temp];
      } else {
        findmid();
      }
    }
  }
  return 0;
}

```

